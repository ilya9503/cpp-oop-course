/*
    Операция присваивания по умолчанию уже работает на уровне объектов любого класса и выполняет побайтное копирование содержимого одного
        объекта в другой.
    Но это не всегда желаемое поведение. Как пример, рассмотрим реализацию известной структуры данных – динамического массива.
        capacity - физическая длина массива
        length - кол-во записанных данных в массив
    При условии length == capacity
        1. Создается новый массив удвоенной длины
        2. Содержимое прежнего массива копируется в новый

    Так как каждый объект класса DArray формирует свой массив data, то необходимо переопределить (С++11, правило 3-ех):
        конструктор копирования;
        деструктор;
        операцию присваивания.
    Начиная со стандарта C++14 правило трех превратилось в правило пяти, добавилось еще два метода:
        конструктор перемещения;
        конструктор копирования перемещением.
*/
#include <iostream>
#include "darray.h"
 
int main()
{
    DArray ar1, ar2;
 
    for(int i = 0;i < 10; ++i)
        ar1.push_back(i+1);
 
    ar2 = ar1;
 
    std::cout << ar2.size() << " " << ar2.capacity_ar() << std::endl;
    
    for(int i = 0;i < ar2.size(); ++i)
        std::cout << ar2.get_data()[i] << " ";
 
    return 0;
}