/*
    3.8 Понятия lvalue и rvalue выражений, rvalue-ссылки

    lvalue выражения - леводопустимые. Переменные, расположенные в памяти устройства, из которых можно читать данные и записывать.
        Переменные
        Указатели
        Элементы массива
        Обычная ссылка &, указывает на конструкцию связанную с областью памяти
        Метод(функция), возвращает конструкцию связанную с областью памяти
    Характерной особенностью всех lvalue выражений является то, что они связаны прямо или косвенно с областью памяти,
        в которой хранятся данные определенного типа. И часто эти данные можно изменить (присвоить им другие значения),
            если конечно, нет ограничений модификатора const.
            
    rvalue выражения - праводопустимые. Обычно константы, данные, не расположенные в памяти устройства


    lvalue (left value) — "выражение, у которого есть адрес", его можно взять через &, оно стоит слева от присваивания.

    rvalue (right value) — "выражение без собственного адреса", обычно временные объекты, которые появляются "на лету" и потом исчезают.

    Ссылки на rvalue (T&&) нужны, чтобы:
        захватывать временные объекты без лишнего копирования
        оптимизировать производительность через перемещение ресурсов
        строить эффективные конструкции, такие как move-семантика и perfect forwarding
*/

#include <utility>  // std::move()

class Point {
public:
    int x{0}, y{0};
public:
    int& get_x() { return x; }
};

/*
    lvalue-выражения связаны прямо или косвенно с областью памяти, которую можно воспринимать как переменную
        (что-либо заносить и считывать)
    rvalue-выражения связаны с областью памяти, хранящей временные значения и/или не связанной с какой-либо переменной
        (в любом ее проявлении)

    rvalue - живут в памяти устройства - нельзя взять адрес &, но можно &&
        В регистрах процессора, если компилятор оптимизирует
        В стековом фрейме (обычная ситуация)

    lvalue - живут в памяти устройства - можно взять адрес &
        Стеке (например, локальные переменные)
        Динамической памяти (куче) (если выделение через new)
        Статической памяти (например, глобальные переменные)
        
    Объекты в глобальной области (статической), живут все время работы программы (до завершения main)
        Время жизни заранее известно, в отличие от динамического выделения (программист сам решает когда освободить)
    Стековый фрейм - при выходе из функции (локальные переменные)
*/


int main()
{
    Point pt = {1, 2};
    pt.get_x() = 10;

    int b {3};
    int a = 7 - b;
 
    Point pt1;
 
    int& lnk_a = a;
    Point& lnk_pt = pt1;    // классическую ссылку можно сделать только на lvalue-выражение
    const int& lnk_b = 5;   // константную ссылку можно делать на rvalue-выражения
    int&& lnk_b_2 = 5;      // с С++11 можно делать не константные ссылки на rvalue

    int&& lnk_a_rv = static_cast<int&&>(lnk_a);     // преобразование lvalue-ссылки (&) в rvalue-ссылку (&&)
    Point&& lnk_pt_rv = std::move(lnk_pt);          // тоже самое, только более безопасно

    double* ptr_test = new double;
    double& ptr_ref = *ptr_test;

    return 0;
}