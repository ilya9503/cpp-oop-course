/*
    Константные методы. Ключевое слово mutable
    Как сообщить компилятору, что этот или какой-либо другой метод можно вызывать для константного объекта?
    Для этого Бьерн Стауструп предложил такие методы помечать особым образом: записывать после их объявления ключевое слово const

    Вообще в практике программирования рекомендуется все методы, которые не меняют состояние объектов класса, помечать, как константные.
    Тогда программист, пользователь класса, сможет в полной мере, свободно и корректно использовать его в своем проекте.

    В очень редких случаях, которые следует избегать на практике, некоторые переменные объекта можно помечать специальным ключевым
        словом mutable, позволяющее изменять переменную константного объекта.
    mutable - переменный
*/

#include <iostream>

class Point {
    int x {0}, y{0};
 
public:
    mutable int count_call{0};  // счетчик вызванных методов. Без mutable не вызвать в константных методах
    Point(int a = 0, int b = 0) : x(a), y(b)
        { }
    void set_coords(const Point& p) 
    {
        count_call++;
        x = p.x; y = p.y;
        //p.x = 1;    // только для чтения, будет ошибка (объект p const)
        //p.y = 2;
        //p.set_coords(Point(10, 20));
        p.get_coords(x, y); // компилятор блокирует вызов метода, несмотря на то, что он не меняет объект 
    }
    const int get_x() const     // тут ключевые слова const имеют разное значение (const int - задает возвращаемое зн-е)
        { count_call++; return x; }
    const int get_y() const     // если возвращаем указатель или ссылку, то обязательно const
        { count_call++; return y;  }
    void get_coords(int& x, int& y) const   // если метод константный, то может вызываться у константного объекта
        { count_call++; x = get_x(); y = get_y(); }       // константные методы могут вызывать другие методы (только константные)
};

int main()
{
    Point pt, pt2(1, 2);
 
    pt.set_coords(pt2);
 
    int x, y;
    pt.get_coords(x, y);
    std::cout << x << " " << y << std::endl;
    std::cout << pt.count_call << " " << std::endl;
    return 0;
}